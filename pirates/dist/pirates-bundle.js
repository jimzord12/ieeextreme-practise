"use strict";var __create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__copyProps=(e,t,s,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let o of __getOwnPropNames(t))__hasOwnProp.call(e,o)||o===s||__defProp(e,o,{get:()=>t[o],enumerable:!(n=__getOwnPropDesc(t,o))||n.enumerable});return e},__toESM=(e,t,s)=>(s=null!=e?__create(__getProtoOf(e)):{},__copyProps(!t&&e&&e.__esModule?s:__defProp(s,"default",{value:e,enumerable:!0}),e)),import_readline=__toESM(require("readline"),1),MapTile=class{pos;type;constructor(e,t){this.pos=e,this.type=t}get isLand(){return"land"===this.type}get isWater(){return"water"===this.type}isConnectedWith(e){return this.isConnectedHorizontally(e)||this.isConnectedVertically(e)||this.isConnectedDiagonally(e)}isConnectedWithGroup(e){return e.tiles.filter((e=>this.isConnectedWith(e))).length>0}isConnectedHorizontally(e){return this.pos.row===e.pos.row&&(this.pos.column===e.pos.column+1||this.pos.column===e.pos.column-1)}isConnectedVertically(e){return this.pos.column===e.pos.column&&(this.pos.row===e.pos.row+1||this.pos.row===e.pos.row-1)}isConnectedDiagonally(e){return this.pos.row===e.pos.row+1&&this.pos.column===e.pos.column+1||this.pos.row===e.pos.row-1&&this.pos.column===e.pos.column-1||this.pos.row===e.pos.row+1&&this.pos.column===e.pos.column-1||this.pos.row===e.pos.row-1&&this.pos.column===e.pos.column+1}},ArchipelagoMap=class e{islands=[];seas=[];mapSize={rows:0,columns:0,totalTiles:0};map=[];allLandTiles=[];allSeaTiles=[];allNodes=new Set;currentId=0;static directions=[{row:0,column:-1},{row:0,column:1},{row:-1,column:0},{row:1,column:0},{row:1,column:1},{row:1,column:-1},{row:-1,column:1},{row:-1,column:-1}];piratesTile=null;treasureTile=null;constructor(e,t){this.mapSize={rows:e,columns:t,totalTiles:e*t}}setPiratesTile(e){this.piratesTile=e}setTreasureTile(e){this.treasureTile=e}generateMap(e){const t=e.split("\n");t.forEach(((e,t)=>{this.map.push(this.generateMapRow(e,t))})),this.map=t.map(((e,t)=>this.generateMapRow(e,t)))}generateMapRow(e,t){const s=e.split("").map(((e,s)=>{const n="O"===e?"land":"water",o=new MapTile({row:t,column:s+1},n);return"land"===n?this.allLandTiles.push(o):this.allSeaTiles.push(o),o}));return this.map.push(s),s}createTheIslands(){const e=[],t=new Set(this.allLandTiles);for(;t.size>0;){const s=t.values().next().value;if(!s)break;const{tiles:n}=this.findConnectedTiles(s);if(0===n.length)continue;const o={id:++this.currentId,tiles:n,connectedTo:new Set,type:"island",size:n.length};e.push(o),n.forEach((e=>t.delete(e)))}this.islands=e,e.forEach(((e,t)=>{}))}createTheSeas(){const e=[],t=new Set(this.allSeaTiles);for(;t.size>0;){const s=t.values().next().value;if(!s)break;const{tiles:n}=this.findConnectedTiles(s);if(0===n.length)continue;const o={id:++this.currentId,tiles:n,connectedTo:new Set,type:"sea",size:n.length};e.push(o),n.forEach((e=>t.delete(e)))}this.seas=e,e.forEach(((e,t)=>{}))}findConnectedTiles(e){const t=new Set,s=new Set,n=new Set;let o=e;this.findConnectedNeighbours(o).forEach((e=>n.add(e))),t.add(o),s.add(o);for(;n.size>0;){n.forEach((e=>{n.delete(e),t.add(e),s.add(e),this.findConnectedNeighbours(e).forEach((e=>{t.has(e)||n.add(e)}))}));const e=n.values().next().value;if(!e)break;o=e}return s.size<2?{tiles:[],type:"land"}:{tiles:Array.from(s),type:o.type}}findConnectedNeighbours(t){const s=[],{row:n,column:o}=t.pos;for(let i=0;i<e.directions.length;i++){const{row:r,column:l}=e.directions[i],a=o+l-1,c=n+r-1;if(a<0||a>=this.mapSize.columns)continue;if(c<0||c>=this.mapSize.rows)continue;const p=this.map[c][a];p.pos.row===t.pos.row&&p.pos.column===t.pos.column||t.type===p.type&&s.push(p)}return s}isConnectedWith(e,t){return e.connectedTo.has(t.id)}find_islands_and_seas_connections(){this.islands.forEach((e=>{e.tiles.forEach((t=>{this.seas.some((s=>{if(t.isConnectedWithGroup(s))return e.connectedTo.add(s.id),!0}))}))})),this.seas.forEach((e=>{e.tiles.forEach((t=>{this.islands.some((s=>{if(t.isConnectedWithGroup(s))return e.connectedTo.add(s.id),!0}))}))}))}findPiratesSea(e){if(null===e)throw new Error("Pirates' Tile is null");const t=this.seas.find((t=>t.tiles.some((t=>t.pos.row===e?.pos.row&&t.pos.column===e?.pos.column))));if(void 0===t)throw new Error("Pirates' Sea not founds");return t}findTreasureSea(e){if(null===e)throw new Error("Treasure's Tile is null");const t=this.seas.find((t=>t.tiles.some((t=>t.pos.row===e?.pos.row&&t.pos.column===e?.pos.column))));if(void 0===t)throw new Error("Treasure's Sea not founds");return t}isTileConnectedWithGrp(e,t){return t.tiles.some((t=>e.isConnectedWith(t)))}findConnectedGrps(e){const t=new Set;return"island"===e.type&&e.tiles.forEach((e=>{this.seas.forEach((s=>{this.isTileConnectedWithGrp(e,s)&&!t.has(s)&&t.add(s)}))})),"sea"===e.type&&e.tiles.forEach((e=>{this.islands.forEach((s=>{this.isTileConnectedWithGrp(e,s)&&!t.has(s)&&t.add(s)}))})),Array.from(t)}createNodes(e,t,s){if(s.has(e.id))return;s.add(e.id);const n=this.findConnectedGrps(e).filter((e=>!s.has(e.id)&&t?.id!==e.id));this.allNodes.add({prev:t,next:0===n.length?null:n,self:e}),n.forEach((t=>this.createNodes(t,e,s)))}enhanceNodes(){this.allNodes.forEach((e=>{const{next:t,prev:s}=e,n=[];if(t&&(t.forEach((e=>{const t=this.findNodeFromGrp(e);t&&n.push(t)})),e.next=n),s){const t=this.findNodeFromGrp(s);t&&(e.prev=t)}}))}findNodeFromGrp(e){return Array.from(this.allNodes).find((t=>t.self.id===e.id))}emptyAllNodes=()=>{this.allNodes=new Set};getBestPath(e,t){this.emptyAllNodes();const s=this.findPiratesSea(e),n=this.findTreasureSea(t);this.createNodes(s,null,new Set),this.enhanceNodes();let o=[];const i=new Set,r=[],l=[];let a=this.findNodeFromGrp(s);for(;i.size<this.allNodes.size&&a;)if(a.self.id===n.id&&l.push([...r,a]),i.has(a)||null===a.next)o.shift(),r.pop(),a=o[0];else{if(i.add(a),a.next){r.push(a);o=[...[...a.next],...o]}a=o[0]}return l.map((e=>e.filter((e=>"island"===e.self.type)))).sort(((e,t)=>e.length-t.length))[0]}},isWhitespace=e=>" \t\n\r\v".includes(e),clearWhitespaces=e=>{for(;e.inputCursor<e.inputStdin.length&&isWhitespace(e.inputStdin[e.inputCursor]);)e.inputCursor++},nextString=e=>{clearWhitespaces(e);let t="";for(;e.inputCursor<e.inputStdin.length&&!isWhitespace(e.inputStdin[e.inputCursor]);)t+=e.inputStdin[e.inputCursor++];return t},nextInt=e=>parseInt(nextString(e),10),main=async e=>{const t=nextInt(e),s=nextInt(e),n=nextInt(e),o=new ArchipelagoMap(t,s);for(let s=1;s<t+1;s++){const t=nextString(e);o.generateMapRow(t,s)}o.map.forEach(((e,t)=>{}));const i=[];for(let t=0;t<n;t++){const t=nextInt(e),s=nextInt(e),n=nextInt(e),o=nextInt(e);i.push({x1:t,y1:s,x2:n,y2:o})}o.createTheIslands(),o.createTheSeas(),o.find_islands_and_seas_connections(),i.forEach((e=>{const t=new MapTile({row:e.x1,column:e.y1},"water"),s=new MapTile({row:e.x2,column:e.y2},"water"),n=o.getBestPath(t,s);console.log(n.length)}))},rl=import_readline.default.createInterface({input:process.stdin,output:process.stdout}),stdinInput={inputStdin:"",inputCursor:0};rl.on("line",(e=>{stdinInput.inputStdin+=e+"\n"})),rl.on("close",(()=>{main(stdinInput)}));
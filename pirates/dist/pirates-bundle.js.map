{
  "version": 3,
  "sources": ["../entry.ts", "../classes/tile.ts", "../classes/map.ts", "../utils.ts", "../main.ts"],
  "sourcesContent": ["import readline from \"readline\";\r\nimport { StdinInput } from \"./types.js\";\r\nimport { main } from \"./main.js\";\r\n\r\nconst rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout,\r\n});\r\n\r\nconst stdinInput: StdinInput = {\r\n  inputStdin: \"\",\r\n  inputCursor: 0,\r\n};\r\n\r\n// Reading the input from the standard input\r\nrl.on(\"line\", (input: string) => {\r\n  stdinInput.inputStdin += input + \"\\n\";\r\n});\r\n\r\n// Main function that is called after reading the input\r\nrl.on(\"close\", () => {\r\n  main(stdinInput);\r\n});\r\n", "import { IIsland, IMapTile, ISea, MapPotision, MapTileType } from \"../types.js\";\r\n\r\nexport class MapTile implements IMapTile {\r\n  public pos: MapPotision;\r\n  public type: MapTileType;\r\n\r\n  public constructor(pos: MapPotision, type: MapTileType) {\r\n    this.pos = pos;\r\n    this.type = type;\r\n  }\r\n\r\n  public get isLand(): boolean {\r\n    return this.type === \"land\";\r\n  }\r\n\r\n  public get isWater(): boolean {\r\n    return this.type === \"water\";\r\n  }\r\n\r\n  public isConnectedWith(comparisonTile: MapTile): boolean {\r\n    return (\r\n      this.isConnectedHorizontally(comparisonTile) ||\r\n      this.isConnectedVertically(comparisonTile) ||\r\n      this.isConnectedDiagonally(comparisonTile)\r\n    );\r\n  }\r\n\r\n  public isConnectedWithGroup(group: IIsland | ISea): boolean {\r\n    const connectedTiles = group.tiles.filter((tile) =>\r\n      this.isConnectedWith(tile)\r\n    );\r\n\r\n    return connectedTiles.length > 0;\r\n  }\r\n\r\n  private isConnectedHorizontally(comparisonTile: MapTile): boolean {\r\n    return (\r\n      this.pos.row === comparisonTile.pos.row &&\r\n      (this.pos.column === comparisonTile.pos.column + 1 ||\r\n        this.pos.column === comparisonTile.pos.column - 1)\r\n    );\r\n  }\r\n\r\n  private isConnectedVertically(comparisonTile: MapTile): boolean {\r\n    return (\r\n      this.pos.column === comparisonTile.pos.column &&\r\n      (this.pos.row === comparisonTile.pos.row + 1 ||\r\n        this.pos.row === comparisonTile.pos.row - 1)\r\n    );\r\n  }\r\n\r\n  private isConnectedDiagonally(comparisonTile: MapTile): boolean {\r\n    return (\r\n      (this.pos.row === comparisonTile.pos.row + 1 &&\r\n        this.pos.column === comparisonTile.pos.column + 1) ||\r\n      (this.pos.row === comparisonTile.pos.row - 1 &&\r\n        this.pos.column === comparisonTile.pos.column - 1) ||\r\n      (this.pos.row === comparisonTile.pos.row + 1 &&\r\n        this.pos.column === comparisonTile.pos.column - 1) ||\r\n      (this.pos.row === comparisonTile.pos.row - 1 &&\r\n        this.pos.column === comparisonTile.pos.column + 1)\r\n    );\r\n  }\r\n}\r\n", "import {\r\n  IArchipelagoMap,\r\n  IIsland,\r\n  ISea,\r\n  LandTile,\r\n  MapPotision,\r\n  MapRow,\r\n  MapSize,\r\n  MapTileType,\r\n  MyNode,\r\n  SeaTile,\r\n} from \"../types.js\";\r\nimport { MapTile } from \"./tile.js\";\r\n\r\nexport class ArchipelagoMap implements IArchipelagoMap {\r\n  public islands: IIsland[] = [];\r\n  public seas: ISea[] = [];\r\n  public mapSize: MapSize = { rows: 0, columns: 0, totalTiles: 0 };\r\n  public map: MapRow[] = [];\r\n  public allLandTiles: LandTile[] = [];\r\n  public allSeaTiles: SeaTile[] = [];\r\n  public allNodes = new Set<MyNode>();\r\n  public currentId = 0;\r\n  private static directions = [\r\n    { row: 0, column: -1 }, // left\r\n    { row: 0, column: 1 }, // right\r\n    { row: -1, column: 0 }, // up\r\n    { row: 1, column: 0 }, // down\r\n    { row: 1, column: 1 }, // down-right\r\n    { row: 1, column: -1 }, // down-left\r\n    { row: -1, column: 1 }, // up-right\r\n    { row: -1, column: -1 }, // up-left\r\n  ];\r\n  public piratesTile: SeaTile | null = null;\r\n  public treasureTile: SeaTile | null = null;\r\n\r\n  public constructor(rows: number, columns: number) {\r\n    this.mapSize = { rows, columns, totalTiles: rows * columns };\r\n\r\n    // this.map = this.generateMap();\r\n  }\r\n\r\n  public setPiratesTile(tile: SeaTile) {\r\n    this.piratesTile = tile;\r\n  }\r\n\r\n  public setTreasureTile(tile: SeaTile) {\r\n    this.treasureTile = tile;\r\n  }\r\n\r\n  public generateMap(mapSymbols: string): void {\r\n    const rows = mapSymbols.split(\"\\n\");\r\n\r\n    rows.forEach((rowSymbols, rowIndex) => {\r\n      this.map.push(this.generateMapRow(rowSymbols, rowIndex));\r\n    });\r\n\r\n    this.map = rows.map((rowSymbols, rowIndex) =>\r\n      this.generateMapRow(rowSymbols, rowIndex)\r\n    );\r\n  }\r\n\r\n  public generateMapRow(rowSymbols: string, rowIndex: number): MapRow {\r\n    const tiles = rowSymbols.split(\"\");\r\n\r\n    const mapRow = tiles.map((tileSymbol, column) => {\r\n      const type = tileSymbol === \"O\" ? \"land\" : \"water\";\r\n      const tile = new MapTile({ row: rowIndex, column: column + 1 }, type);\r\n\r\n      if (type === \"land\") {\r\n        this.allLandTiles.push(tile as LandTile);\r\n      } else {\r\n        this.allSeaTiles.push(tile as SeaTile);\r\n      }\r\n\r\n      return tile;\r\n    });\r\n\r\n    this.map.push(mapRow);\r\n    return mapRow;\r\n  }\r\n\r\n  public createTheIslands(): void {\r\n    const islands: IIsland[] = [];\r\n    const uncheckedTiles = new Set<MapTile>(this.allLandTiles);\r\n\r\n    while (uncheckedTiles.size > 0) {\r\n      // console.log(\"\\n1 - Unchecked Tiles: \", uncheckedTiles.size);\r\n      const nextTile = uncheckedTiles.values().next().value;\r\n      if (!nextTile) break;\r\n\r\n      const { tiles } = this.findConnectedTiles(nextTile);\r\n\r\n      if (tiles.length === 0) continue;\r\n\r\n      const island = {\r\n        id: ++this.currentId,\r\n        tiles: tiles,\r\n        connectedTo: new Set<number>(),\r\n        type: \"island\",\r\n        size: tiles.length,\r\n      };\r\n\r\n      islands.push(island);\r\n      tiles.forEach((tile) => uncheckedTiles.delete(tile));\r\n      // console.log(\"2 - Unchecked Tiles: \", uncheckedTiles.size);\r\n    }\r\n\r\n    this.islands = islands;\r\n    islands.forEach((island, index) => {\r\n      // console.log(`The Island ${index + 1}: `, island.tiles.length);\r\n    });\r\n    // console.log(\"Total Land Tiles: \", this.allLandTiles.length);\r\n  }\r\n\r\n  public createTheSeas(): void {\r\n    const seas: ISea[] = [];\r\n    const uncheckedTiles = new Set<MapTile>(this.allSeaTiles);\r\n\r\n    while (uncheckedTiles.size > 0) {\r\n      // console.log(\"\\n(Seas) 1 - Unchecked Tiles: \", uncheckedTiles.size);\r\n      const nextTile = uncheckedTiles.values().next().value;\r\n      if (!nextTile) break;\r\n\r\n      const { tiles } = this.findConnectedTiles(nextTile);\r\n\r\n      if (tiles.length === 0) continue;\r\n\r\n      const sea = {\r\n        id: ++this.currentId,\r\n        tiles: tiles,\r\n        connectedTo: new Set<number>(),\r\n        type: \"sea\",\r\n        size: tiles.length,\r\n      };\r\n\r\n      seas.push(sea);\r\n      tiles.forEach((tile) => uncheckedTiles.delete(tile));\r\n      // console.log(\"(Seas) 2 - Unchecked Tiles: \", uncheckedTiles.size);\r\n    }\r\n\r\n    this.seas = seas;\r\n    seas.forEach((sea, index) => {\r\n      // console.log(`The sea ${index + 1}: `, sea.tiles.length);\r\n    });\r\n    // console.log(\"Total Water Tiles: \", this.allSeaTiles.length);\r\n  }\r\n\r\n  private findConnectedTiles(startingTile: MapTile): {\r\n    tiles: MapTile[];\r\n    type: MapTileType;\r\n  } {\r\n    const checkedTiles = new Set<MapTile>();\r\n    const connectedTiles = new Set<MapTile>();\r\n    const uncheckedTiles = new Set<MapTile>();\r\n    let currentTile: MapTile = startingTile;\r\n\r\n    const neighbours = this.findConnectedNeighbours(currentTile);\r\n    // console.log(\"\\nStarting Tile: \", startingTile.pos);\r\n    // console.log(\"\\nStarting Neighbours: \", neighbours.length);\r\n    neighbours.forEach((nbr) => uncheckedTiles.add(nbr));\r\n    checkedTiles.add(currentTile);\r\n    connectedTiles.add(currentTile);\r\n\r\n    let i = 0;\r\n    while (uncheckedTiles.size > 0) {\r\n      uncheckedTiles.forEach((t) => {\r\n        uncheckedTiles.delete(t);\r\n        checkedTiles.add(t);\r\n        connectedTiles.add(t);\r\n\r\n        this.findConnectedNeighbours(t).forEach((nbr) => {\r\n          if (checkedTiles.has(nbr)) return;\r\n          uncheckedTiles.add(nbr);\r\n        });\r\n      });\r\n\r\n      const nextTile = uncheckedTiles.values().next().value;\r\n      if (!nextTile) break;\r\n      currentTile = nextTile;\r\n      i++;\r\n    }\r\n\r\n    // console.log(\"\");\r\n    // console.log(\"1. findConnectedTiles: Unchecked Tiles: \", uncheckedTiles);\r\n    // console.log(\"2. findConnectedTiles: Checked Tiles: \", checkedTiles);\r\n    // console.log(\"3. findConnectedTiles: Connected Tiles: \", connectedTiles);\r\n    // console.log(\"4. findConnectedTiles: Next Tile: \", currentTile);\r\n    // console.log(\"\");\r\n\r\n    if (connectedTiles.size < 2) return { tiles: [], type: \"land\" };\r\n\r\n    return {\r\n      tiles: Array.from(connectedTiles),\r\n      type: currentTile.type,\r\n    };\r\n  }\r\n\r\n  private findConnectedNeighbours(tile: MapTile): MapTile[] {\r\n    const connectedNeighbours: MapTile[] = [];\r\n    const { row: tileRow, column: tileCol } = tile.pos;\r\n\r\n    for (let index = 0; index < ArchipelagoMap.directions.length; index++) {\r\n      const { row: y, column: x } = ArchipelagoMap.directions[index];\r\n      const xCord = tileCol + x - 1;\r\n      const yCord = tileRow + y - 1;\r\n\r\n      if (xCord < 0 || xCord >= this.mapSize.columns) continue;\r\n      if (yCord < 0 || yCord >= this.mapSize.rows) continue;\r\n\r\n      const neighbour = this.map[yCord][xCord];\r\n\r\n      if (\r\n        neighbour.pos.row === tile.pos.row &&\r\n        neighbour.pos.column === tile.pos.column\r\n      )\r\n        continue;\r\n\r\n      // console.log(\"\\nCurrent: \", tile);\r\n      // console.log(\"Neighbour: \", neighbour);\r\n\r\n      if (tile.type === neighbour.type) {\r\n        // console.log(\"Neighbour PASSED: \", neighbour);\r\n        connectedNeighbours.push(neighbour);\r\n      }\r\n    }\r\n\r\n    // console.log(\"Finished\");\r\n    return connectedNeighbours;\r\n  }\r\n\r\n  isConnectedWith(groupA: IIsland | ISea, groupB: IIsland | ISea): boolean {\r\n    return groupA.connectedTo.has(groupB.id);\r\n  }\r\n\r\n  public find_islands_and_seas_connections(): void {\r\n    this.islands.forEach((island) => {\r\n      island.tiles.forEach((landTile) => {\r\n        this.seas.some((sea) => {\r\n          const _isConnected = landTile.isConnectedWithGroup(sea);\r\n          if (_isConnected) {\r\n            island.connectedTo.add(sea.id);\r\n            return true;\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    this.seas.forEach((sea) => {\r\n      sea.tiles.forEach((seaTile) => {\r\n        this.islands.some((island) => {\r\n          // if (island.connectedTo.has(sea.id)) return true;\r\n\r\n          const _isConnected = seaTile.isConnectedWithGroup(island);\r\n          if (_isConnected) {\r\n            sea.connectedTo.add(island.id);\r\n            return true;\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  findPiratesSea(piratesTile: MapTile): ISea {\r\n    if (piratesTile === null) throw new Error(\"Pirates' Tile is null\");\r\n    const sea = this.seas.find((sea) =>\r\n      sea.tiles.some(\r\n        (tile) =>\r\n          tile.pos.row === piratesTile?.pos.row &&\r\n          tile.pos.column === piratesTile?.pos.column\r\n      )\r\n    );\r\n    if (sea === undefined) throw new Error(`Pirates' Sea not founds`);\r\n    return sea;\r\n  }\r\n\r\n  findTreasureSea(treasureTile: MapTile): ISea {\r\n    if (treasureTile === null) throw new Error(\"Treasure's Tile is null\");\r\n    const sea = this.seas.find((sea) =>\r\n      sea.tiles.some(\r\n        (tile) =>\r\n          tile.pos.row === treasureTile?.pos.row &&\r\n          tile.pos.column === treasureTile?.pos.column\r\n      )\r\n    );\r\n    if (sea === undefined) throw new Error(\"Treasure's Sea not founds\");\r\n    return sea;\r\n  }\r\n\r\n  private isTileConnectedWithGrp(tile: MapTile, grp: IIsland | ISea) {\r\n    return grp.tiles.some((grpTile) => tile.isConnectedWith(grpTile));\r\n  }\r\n\r\n  private findConnectedGrps(grp: IIsland | ISea): IIsland[] | ISea[] {\r\n    const connected = new Set<IIsland | ISea>();\r\n\r\n    if (grp.type === \"island\") {\r\n      grp.tiles.forEach((t) => {\r\n        this.seas.forEach((s) => {\r\n          if (this.isTileConnectedWithGrp(t, s) && !connected.has(s))\r\n            connected.add(s);\r\n        });\r\n      });\r\n    }\r\n\r\n    if (grp.type === \"sea\") {\r\n      grp.tiles.forEach((t) => {\r\n        this.islands.forEach((i) => {\r\n          if (this.isTileConnectedWithGrp(t, i) && !connected.has(i))\r\n            connected.add(i);\r\n        });\r\n      });\r\n    }\r\n\r\n    return Array.from(connected);\r\n  }\r\n\r\n  public createNodes(\r\n    grp: IIsland | ISea,\r\n    prev: IIsland | ISea | null,\r\n    visited: Set<number>\r\n  ) {\r\n    // If the group has already been visited, return early to avoid infinite recursion\r\n    if (visited.has(grp.id)) {\r\n      return;\r\n    }\r\n\r\n    // Mark this group as visited\r\n    visited.add(grp.id);\r\n\r\n    // console.log(\"Current Grp ID: \", grp.id);\r\n\r\n    const connectedGrps = this.findConnectedGrps(grp);\r\n    // console.log(\"ConnectedGrps before filter: \", connectedGrps);\r\n    const filteredGrps = connectedGrps.filter((g) => {\r\n      // console.log(\"\\n******************************************\");\r\n      // console.log(\"Target Group ID: \", g.id);\r\n      // console.log(\"Target Group's PREV ID: \", prev?.id);\r\n      // console.log(\"Is True: \", !visited.has(g.id) && prev?.id !== g.id);\r\n\r\n      return !visited.has(g.id) && prev?.id !== g.id;\r\n    });\r\n\r\n    // console.log(\"\\nConnected Groups: \", filteredGrps);\r\n    this.allNodes.add({\r\n      prev: prev,\r\n      next: filteredGrps.length === 0 ? null : filteredGrps,\r\n      self: grp,\r\n    });\r\n\r\n    filteredGrps.forEach((g) => this.createNodes(g, grp, visited));\r\n  }\r\n\r\n  public enhanceNodes() {\r\n    this.allNodes.forEach((node) => {\r\n      const { next, prev } = node;\r\n      const newNextNodes: MyNode[] = [];\r\n\r\n      if (next) {\r\n        next.forEach((n) => {\r\n          const nextNode = this.findNodeFromGrp(n as IIsland | ISea);\r\n          if (nextNode) {\r\n            newNextNodes.push(nextNode);\r\n          }\r\n        });\r\n\r\n        node.next = newNextNodes;\r\n      }\r\n\r\n      if (prev) {\r\n        const prevNode = this.findNodeFromGrp(prev as IIsland | ISea);\r\n        if (prevNode) {\r\n          node.prev = prevNode;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private findNodeFromGrp(grp: IIsland | ISea): MyNode | undefined {\r\n    return Array.from(this.allNodes).find((node) => node.self.id === grp.id);\r\n  }\r\n\r\n  private emptyAllNodes = () => {\r\n    this.allNodes = new Set<MyNode>();\r\n  };\r\n\r\n  public getBestPath(pirates: MapTile, treasure: MapTile) {\r\n    this.emptyAllNodes();\r\n    const piratesSea = this.findPiratesSea(pirates);\r\n    const treasureSea = this.findTreasureSea(treasure);\r\n\r\n    // console.log(\"\\nPirates Sea: \", piratesSea);\r\n    // console.log(\"Treasure Sea: \", treasureSea);\r\n\r\n    this.createNodes(piratesSea, null, new Set());\r\n    this.enhanceNodes();\r\n\r\n    let queue: MyNode[] = [];\r\n    const visited = new Set<MyNode>();\r\n    const currentPath = [];\r\n    const allPaths: MyNode[][] = [];\r\n    let currentNode = this.findNodeFromGrp(piratesSea) as MyNode;\r\n\r\n    // console.log(\"\\nAll Nodes: \", this.allNodes);\r\n    // console.log(\"++++++++++++++++++++++++++++\");\r\n\r\n    while (visited.size < this.allNodes.size) {\r\n      if (!currentNode) {\r\n        // throw new Error(`Current Node not found`);\r\n        break;\r\n      }\r\n\r\n      if (currentNode.self.id === treasureSea.id) {\r\n        allPaths.push([...currentPath, currentNode]);\r\n      }\r\n\r\n      if (visited.has(currentNode) || currentNode.next === null) {\r\n        // console.log(\"###########################################\");\r\n        // console.log(\"0 - aaaaaaaaaa: \", currentNode.self.id);\r\n        // console.log(\"1 - aaaaaaaaaa: \", visited.has(currentNode));\r\n        // console.log(\"2 - aaaaaaaaaa: \", currentNode.next === null);\r\n        // console.log(\"###########################################\");\r\n        queue.shift();\r\n        currentPath.pop();\r\n        currentNode = queue[0] as MyNode;\r\n\r\n        continue;\r\n      }\r\n\r\n      visited.add(currentNode);\r\n      // console.log(\"\\n**********************************\");\r\n      if (currentNode.next) {\r\n        currentPath.push(currentNode);\r\n        const newNodes = [...currentNode.next] as MyNode[];\r\n        queue = [...newNodes, ...queue];\r\n        // console.log(\"Current Node: \", currentNode.self.id);\r\n        // console.log(\"--------------------------------------------------\");\r\n        // console.log(\r\n        //   \"Queue: \",\r\n        //   queue.map((n) => n.self.id)\r\n        // );\r\n        // console.log(\"---------------------------------------------d-----\");\r\n        // console.log(\r\n        //   \"Current Path: \",\r\n        //   currentPath.map((n) => n.self.id)\r\n        // );\r\n        // console.log(\"--------------------------------------------------\");\r\n        // console.log(\"Visited: \", visited.size);\r\n      }\r\n      //  else {\r\n      //   queue.shift();\r\n      //   currentPath.pop();\r\n      // }\r\n\r\n      currentNode = queue[0] as MyNode;\r\n    }\r\n\r\n    // let bestPath\r\n    const onlyIslandNodes = allPaths.map((path) =>\r\n      path.filter((node) => node.self.type === \"island\")\r\n    );\r\n    const sorted = onlyIslandNodes.sort((a, b) => a.length - b.length);\r\n    // console.log(\"Sorted: \", sorted);\r\n\r\n    return sorted[0];\r\n  }\r\n\r\n  // public convertMapTilesToNodes() {}\r\n}\r\n\r\n// Current:  MapTile { pos: { row: 3, column: 7 }, type: 'water' }\r\n// Neighbour PASSED:  MapTile { pos: { row: 3, column: 9 }, type: 'water' }\r\n", "import { StdinInput } from \"./types.js\";\r\n\r\nconst isWhitespace = (character: string): boolean =>\r\n  \" \\t\\n\\r\\v\".includes(character);\r\n\r\nconst clearWhitespaces = (stdinInput: StdinInput): void => {\r\n  while (\r\n    stdinInput.inputCursor < stdinInput.inputStdin.length &&\r\n    isWhitespace(stdinInput.inputStdin[stdinInput.inputCursor])\r\n  ) {\r\n    stdinInput.inputCursor++;\r\n  }\r\n};\r\n\r\nconst nextString = (stdinInput: StdinInput): string => {\r\n  clearWhitespaces(stdinInput);\r\n  let nextString = \"\";\r\n  while (\r\n    stdinInput.inputCursor < stdinInput.inputStdin.length &&\r\n    !isWhitespace(stdinInput.inputStdin[stdinInput.inputCursor])\r\n  ) {\r\n    nextString += stdinInput.inputStdin[stdinInput.inputCursor++];\r\n  }\r\n  return nextString;\r\n};\r\n\r\nconst nextInt = (stdinInput: StdinInput): number =>\r\n  parseInt(nextString(stdinInput), 10);\r\n\r\nconst nextFloat = (stdinInput: StdinInput): number =>\r\n  parseFloat(nextString(stdinInput));\r\n\r\nconst nextChar = (stdinInput: StdinInput): string => {\r\n  clearWhitespaces(stdinInput);\r\n  return stdinInput.inputCursor < stdinInput.inputStdin.length\r\n    ? stdinInput.inputStdin[stdinInput.inputCursor++]\r\n    : \"\\0\";\r\n};\r\n\r\nexport const roundTo = (n: number, digits: number = 0) => {\r\n  const multiplicator = Math.pow(10, digits);\r\n  n = parseFloat((n * multiplicator).toFixed(11));\r\n  return Math.round(n) / multiplicator;\r\n};\r\n\r\nexport {\r\n  isWhitespace,\r\n  clearWhitespaces,\r\n  nextString,\r\n  nextInt,\r\n  nextFloat,\r\n  nextChar,\r\n};\r\n", "import { ArchipelagoMap } from \"./classes/map.js\";\r\nimport { MapTile } from \"./classes/tile.js\";\r\nimport { Query, SeaTile, StdinInput } from \"./types.js\";\r\nimport { nextInt, nextString } from \"./utils.js\";\r\n\r\nexport const main = async (stdinInput: StdinInput) => {\r\n  // console.log(\"Welcome to the Pirates Code Challenge!\\n\");\r\n  // console.log(\"The Stdin Input:\\n\", stdinInput);\r\n\r\n  // Parse input for the challenge\r\n  const rows: number = nextInt(stdinInput); // Map rows\r\n  const cols: number = nextInt(stdinInput); // Map columns\r\n  const querriesNum: number = nextInt(stdinInput); // Number of queries\r\n\r\n  const archipelagoMap = new ArchipelagoMap(rows, cols);\r\n  // console.log(\"#1 Archipelago Map: \", archipelagoMap);\r\n\r\n  // Parse the strings containing symbols that represent the types of map tiles.\r\n  // Generate the map, one row at a time.\r\n  for (let i = 1; i < rows + 1; i++) {\r\n    const rowSymbols = nextString(stdinInput);\r\n    archipelagoMap.generateMapRow(rowSymbols, i);\r\n  }\r\n\r\n  // Just logging the map\r\n  archipelagoMap.map.forEach((row, i) => {\r\n    // console.log(`(${i + 1}) - Row: `, row);\r\n  });\r\n\r\n  const querries: Query[] = [];\r\n\r\n  // Parse the queries\r\n  for (let i = 0; i < querriesNum; i++) {\r\n    const p_x1: number = nextInt(stdinInput);\r\n    const p_y1: number = nextInt(stdinInput);\r\n    const t_x2: number = nextInt(stdinInput);\r\n    const t_y2: number = nextInt(stdinInput);\r\n    querries.push({ x1: p_x1, y1: p_y1, x2: t_x2, y2: t_y2 });\r\n  }\r\n\r\n  // console.log(\"Querries: \", querries);\r\n\r\n  archipelagoMap.createTheIslands();\r\n  archipelagoMap.createTheSeas();\r\n\r\n  // archipelagoMap.islands.forEach((island, i) => {\r\n  //   // console.log(`Island ${i}: `, island);\r\n  //   // console.log(island.landTiles);\r\n  // });\r\n\r\n  // archipelagoMap.seas.forEach((sea, i) => {\r\n  //   // console.log(`Sea ${i}: `, sea);\r\n  //   // console.log(sea.waterTiles);\r\n  // });\r\n\r\n  // archipelagoMap.setPiratesTile(\r\n  //   new MapTile(\r\n  //     { row: querries[0].x1, column: querries[0].y1 },\r\n  //     \"water\"\r\n  //   ) as SeaTile\r\n  // );\r\n\r\n  // console.log(\"\\nPirates Tile: \", archipelagoMap.piratesTile);\r\n\r\n  // const piratesSea = archipelagoMap.findPiratesSea();\r\n  // console.log(\"Pirates Sea: \", piratesSea);\r\n\r\n  archipelagoMap.find_islands_and_seas_connections();\r\n\r\n  // archipelagoMap.createNodes(piratesSea, null, new Set());\r\n\r\n  // archipelagoMap.enhanceNodes();\r\n\r\n  // archipelagoMap.islands.forEach((island) => {\r\n  //   archipelagoMap.enhanceNode(island);\r\n  // });\r\n\r\n  // archipelagoMap.seas.forEach((sea) => {\r\n  //   archipelagoMap.enhanceNode(sea);\r\n  // });\r\n\r\n  // console.log(\"\\n========================================================\");\r\n  // console.log(\"========================================================\");\r\n  //   archipelagoMap.allNodes.forEach((node, i) => {\r\n  //     console.log(`\\nNode ${i.self.id} - Prev: `, node.prev);\r\n  //     console.log(\"------------------------------\");\r\n  //     console.log(`Node ${i.self.id} - Next: `, node.next);\r\n  //     console.log(\"------------------------------\");\r\n  //     console.log(`Node ${i.self.id} - Self: `, node.self);\r\n  //   });\r\n\r\n  querries.forEach((query) => {\r\n    const pirateTile = new MapTile(\r\n      { row: query.x1, column: query.y1 },\r\n      \"water\"\r\n    ) as SeaTile;\r\n\r\n    const treasureTile = new MapTile(\r\n      { row: query.x2, column: query.y2 },\r\n      \"water\"\r\n    ) as SeaTile;\r\n\r\n    // console.log(\"Query: \", query);\r\n    // console.log(\"Pirates Tile: \", pirateTile);\r\n    // console.log(\"Treasure Tile: \", treasureTile);\r\n\r\n    const path = archipelagoMap.getBestPath(pirateTile, treasureTile);\r\n    console.log(path.length);\r\n  });\r\n\r\n  // console.log(\r\n  //   \"\\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\"\r\n  // );\r\n  // path.forEach((node, i) => {\r\n  //   console.log(`\\nPath Node ${i} - Self: `, node.self);\r\n  //   console.log(\"------------------------------\");\r\n  // });\r\n};\r\n\r\n// main({\r\n//   inputCursor: 0,\r\n//   inputStdin:\r\n//     \"4 12 2\\nOOOOO~~OOOOO\\nO~~OO~OO~~~O\\nOO~OO~~O~O~O\\nOOOOOO~OOOOO\\n2 2 3 11\\n4 7 3 9\",\r\n// });\r\n"],
  "mappings": "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",
  "names": ["sea", "stdinInput", "nextString", "stdinInput", "readline"]
}
